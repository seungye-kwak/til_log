추천시스템
===

## 1. 추천시스템 개요
- 추천 : 우리가 다음에 무엇을 하면 좋을지 의사결정을 지원하는 기술. 기업 입장에서는 __사용자의 아이템 구매율을 높이면서 서비스 이용 시간을 늘리는__ 선택 아닌 필수 시스템
- 추천에서 중요한 것 : 정확한(사실보다 나은) 추천 = 예측력, 빠른 추천, 대용량 데이터 처리
- 추천시스템 3요소
  1) 입력(데이터) : 사용자&아이템 콘텐츠 정보, 사용자-아이템 인터랙션 정보 -> 실시간 업데이트
  2) 프로세스(추천 설계) : 개요 추천, 연관아이템 추천, 개인화 추천 설계 방식이 있음
  3) 출력 : UX/UI와 관련됨
- 추천 시스템 유형 : 콘텐츠 기반 필터링, 협업 필터링. 협업 필터링은 최근접 이웃 협업 필터링과 잠재 요인 협업 필터링으로 나뉨


## 2. 콘텐츠(내용) 기반 필터링
- 사용자가 특정한 아이템을 매우 선호하는 경우, 그 아이템과 비슷한 콘텐츠(속성)를 가진 다른 아이템을 추천하는 방식
- ex) 사용자가 특정 영화에 높은 평점을 줬을 대 해당 영화의 장르, 출연 배우, 감독, 영화 키워드 등의 콘텐츠와 유사한 다른 영화를 추천해주는 방식

## 3. 협업 필터링(Collaborative Filetering)
- 사용자가 아이템에 매긴 평점 정보나 상품 구매 이력과 같은 사용자 행동 양식(User Behavior)만을 기반으로 추천을 수행하는 방식
- 사용자-아이템 평점 매트릭스와 같은 축적된 사용자 행동 데이터를 기반으로 사용자가 아직 평가하지 않은 아이템을 예측 평가(Predicted Rating)하는 것
- 협업 필터링에서 사용되는 사용자-아이템 평점 행렬에서 행은 개별 사용자, 열은 개별 아이템으로 구성되며 사용자의 아이디 행, 아이템 아이디 열 위치에 해당하는 값이 평점을 나타내는 형태가 되어야함
- 협업 필터링은 크게 최근접 이웃 협업 필터링과 잠재 요인 협업 필터링으로 나눌 수 있음

  ### 3.1 최근접 이웃 협업 필터링
  - 메모리 협업 필터링이라고도 하며 일반적으로 사용자 기반과 아이템 기반으로 다시 나눌 수 있음
  - 사용자 기반(User-User) : 당신과 비슷한 고객들이 다음 상품도 구매했습니다.
  - 아이템 기반(Item-Item) : 이 상품을 선택한 다른 고객들은 다음 상품도 구매했습니다.  
  ![image](https://github.com/seungye-kwak/til_log/assets/112370282/861249e7-5132-40f2-a582-494c99a51d8e)  

    #### 3.1.1 사용자 기반 최근접 이웃 방식
    - 특정 사용자와 유사한 다른 사용자를 top-n으로 선정해 top-n 사용자가 좋아하는 아이템을 추천하는 방식
    - 즉, 특정 사용자와 타 사용자 간의 유사도(similarity)를 측정한 뒤 가장 유사도가 높은 top-n 사용자를 추출 해 그들이 선호하는 아이템을 추천함
    - 위 그림에서 a유저와 c유저의 유사도가 높기 때문에 c유저가 item3에 대해 a유저와 비슷하게 평점을 1을 줄 것이라고 예측하는 방식

    #### 3.1.2 아이템 기반 최근접 이웃 방식
    - 명칭 때문에 아이템 간의 속성이 얼마나 비슷한지를 기반으로 추천한다고 착각할 수 있지만, __아이템이 가지는 속성과는 상관없이 사용자들이 그 아이템을 좋아하는지/싫어하는지의 평가 척도가 유사한 아이템을 추천하는 기준이 되는__ 알고리즘
    - 위 그림에서 item4와 item6의 사용자들의 평점 분포가 비슷하므로 두 아이템을 비슷한 아이템이라고 묶어 추천하는 방식
    - item4에 좋은 평점을 준 유저d에게 유사한 item6을 추천해줌
    - 일반적으로 사용자 기반보다는 아이템 기반 협업 필터링이 더 정확도가 높음
    - 비슷한 아이템을 좋아한다고 해서 사람들의 취향이 비슷하다고 판단하기는 어려운 경우가 많고, 매우 유명한 아이템은 취향에 상관없이 좋아하는 경우가 많고, 사용자들이 평점을 매긴 아이템 개수가 많지 않은 경우가 일반적이라 유사도를 판단하기에는 무리가 있음

  ### 3.2 잠재 요인 협업 필터링
  - 사용자-아이템 평점 매트릭스 속에 숨어있는 잠재 요인을 추출해 추천 예측을 할 수 있게 하는 기법
  - 대규모 다차원 행렬을 SVD와 같은 차원 감소 기법으로 분해하는 과정에서 잠재 요인을 추출하는데, 이러한 기법을 행렬 분해(Matrix Factorization)라고 함. 넷플릭스 경연대회에서 사용되면서 유명해진 기법
  - 잠재 요인 협업 필터링은 사용자-아이템 평점 행렬 데이터만을 이용해 '잠재 요인'을 찾아내는 것을 의미하는데, '잠재 요인'이 어떤 것인지 명확히 정의할 수는 없음
  - '잠재 요인'을 기반으로 다차원 희소 행렬인 사용자-아이템 행렬 데이터를 저차원 밀집 행렬의 사용자-잠재요인 행렬과 아이템-잠재 요인 행렬의 전치 행렬(즉, 잠재 요인-아이템 행렬)로 분해할 수 있으며, 이렇게 분해된 두 행렬의 내적을 통해 새로운 예측 사용자-아이템 평점 행렬 데이터를 만들어서 사용자가 아직 평점을 부여하지 않는 아이템에 대한 예측 평점을 생성하는 것
  - 행렬 분해 기법을 사용해 사용자-잠재 요인 행렬과 아이템-잠재 요인 행렬의 전치 행렬로 분해된 데이터 세트를 다시 내적곱으로 결합하면서 사용자가 예측하지 않은 아이템에 대한 평점을 도출하는 방식을 개략적으로 나타냄
 
    #### 행렬 분해(Matrix Factorization)
    - 사용자-아이템 평점 행렬과 같이 다차원의 매트릭스를 저차원의 매트릭스로 분해하는 기법을 행렬 분해(Matrix Factorization)이라고 함. 대표적으로는 SVD(Singular Vector Decomposition), NMF(Non-Negative Matrix Factorization) 등이 있음
    ![image](https://github.com/seungye-kwak/til_log/assets/112370282/32933130-0764-4f06-a0bd-d7a32de75cbe)
    ![image](https://github.com/seungye-kwak/til_log/assets/112370282/2b6e7148-4d35-4411-95eb-809d421aeb69)
    - 사용자-아이템 평점 행렬을 R, 사용자 잠재 요인과의 관계 값을 가지는 M x K 차원의 사용자 잠재 요인 행렬을 P, 아이템과 잠재 요인과의 관계 값을 가지는 N x K 차원의 아이템 잠재 요인 행렬을 Q라고 함
    - 이 때, R 행렬을 P와 Q 행렬로 분해하는 방식은 주로 SVD 를 사용하는데 SVD는 널(Nan)값이 없는 행렬에만 적용할 수 있음. R 행렬에는 널값이 많이 있기 때문에 일반적인 SVD 대신 확률정 경사 하강법(Stochastic Gradient Descent, SGD)나 ALS(Alternating Least Squares) 방식을 이용해 SVD를 수행함
      
    #### 확률적 경사 하강법을 이용한 행렬 분해
    - P와 Q 행렬로 계산된 예측 행렬 값이 실제 R 행렬 값과 가장 최소의 오류를 가질 수 있도록 반복적인 비용 함수 최적화를 통해 P와 Q를 유추해내는 것
    - 수행방식
      1) P와 Q를 임의의 값을 가진 행렬로 설정함
      2) P와 Q.T 값을 곱해 예측 R 행렬을 계산하고 예측 R 행렬과 실제 R 행렬에 해당하는 오류 값을 계산함
      3) 이 오류값을 최소화할 수 있도록 P와 Q행렬을 적절한 값으로 각각 업데이트함
      4) 만족할 만한 오류 값을 가질 때까지 2,3번 작업을 반복하면서 P와 Q 값을 업데이트해 근사화 함
    - L2 규제를 고려한 비용 함수 식  
      ![image](https://github.com/seungye-kwak/til_log/assets/112370282/65ec035c-51f8-4d04-b5b7-832b6c24be5b)
    - 비용 함수를 최소화하기 위해 새롭게 업데이트 되는 P 행렬의 사용자 u행 벡터와 Q행렬의 아이템 i행의 전치 벡터  
      ![image](https://github.com/seungye-kwak/til_log/assets/112370282/155bbafa-aaf2-424b-aa7c-f5e2ce526e40)
    - 여기서 학습시켜야 하는 것이 2개의 행렬이고 둘은 곱셈으로 묶여 있어서 이 둘을 동시에 최적화 시키는 문제는 Non-convex problem으로 NP에 속함. Gradietn Descent로 이를 최적화 시키는 것은 너무 느리고 많은 반복이 필요하다는 단점이 있음
    - ALS는 둘 중 하나를 고정시키고 다른 하나를 최적화 시키며 이 과정을 번갈아가며 반복해 짧은 시간 내에 최적의 두 값을 찾아내는 대안


  ### 3.3 메모리 기반 방법과 잠재 요인 협업 필터링 비교
  - 추천에 걸리는 시간 : 메모리 기반 방법에서는 추천 시 매번 모든 데이터에서 비슷한 사용자나 아이템을 찾은 뒤 예측하므로 시간이 걸림. 한편 모델 기반 방법(잠재 요인 협업필터링)은 데이터의 규칙성을 바탕으로 모델을 미리 만들어두고 만들어진 모델만 사용하여 예측하므로 바로 추천할 수 있어서 추천을 수행하는데 시간이 걸리지 않음
  - 운용성 : 메모리 기반 방법은 사용자나 아이템 데이터가 변경돼도 추천할 때마다 모든 데이터를 사용하므로 항상 최신 데이터를 반영해 추천할 수 있음. 모델 기반 방법은 사용자나 아이템 데이터가 변경되고 그 변경을 반영해 추천하려면 모델을 새로 만들어야 하므로 모델 업데이트 시점이나 재학습 걸리는 계산 비용 등을 고려해야 하기 때문에 운용이 비교적 어려움
 
  ### 3.4 내용 기반 필터링과 협업 필터링 비교  
  ![image](https://github.com/seungye-kwak/til_log/assets/112370282/a945610f-6780-446f-acff-c5cacc597ee7)



      
