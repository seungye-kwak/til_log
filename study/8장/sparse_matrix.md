희소행렬
===

## 1. 희소행렬 이해
- 모든 문서에 있는 단어를 추출해 이를 피처로 벡터화하는 방법은 필연적으로 많은 피처 칼럼을 만들 수밖에 없음. 모든 문서에 있는 단어를 중복 제거 후 피처로 만들면 일반적으로 수만 개에서 수십 만개의 단어가 만들어짐
- 이러한 대규모의 행렬이 생성되더라도 레코드의 각 문서가 가지는 단어의 수는 제한적이기 때문에 이 행렬의 값은 대부분 0이 차지할 수밖에 없음
- 이처럼 대규모 행렬의 대부분 값을 0이 차지하는 행렬을 가리켜 희소 행렬이라고 함
- BOW 형태를 가진 언어 모델의 피처 벡터화는 대부분 희소 행렬임. 이 경우 너무 많은 0 값이 메모리 공간에 할당되어 많은 메모리 공간이 필요하고, 연산 시에도 데이터 액세스를 위한 많은 시간이 소모됨
- 따라서 이러한 희소 행렬을 물리적으로 적은 메모리 공간을 차지할 수 있도록 변환해야 하는데, 대표적으로 COO 형식과 CSF 형식이 있음
- 일반적으로 __큰 희소 행렬을 저장하고 계산을 수행하는 능력이 CSR 형식이 더 뛰어나기 때문에 CSR을 많이 사용함__    
![image](https://github.com/seungye-kwak/til_log/assets/112370282/7d670d2d-a243-49ce-9c25-f029ceb1d15a)

### 1.1 COO 형식 (Coordinate: 좌표)
- 0이 아닌 데이터만 별도의 데이터 배열(Array)에 저장하고, 그 데이터가 가리키는 행과열의 위치를 별도의 배열로 저장하는 방식
- 예를 들어 [ [3, 0, 1], [0, 2, 0] ] 과 같은 2차원 데이터가 있다고 할 때 0이 아닌 데이터 위치를 (row, col)로 표현하면 (0,0), (0,2), (1,1)이 됨. 로우와 컬럼을 별도의 배열로 저장하면 로우는 [0, 0, 1], 칼럼은 [0, 2, 1]이 됨
- 파이썬 세계에서는 희소 행렬 변환을 위해서 주로 사이파이(Scipy)를 이용함. 사이파이의 sparse를 이용해 희소 행렬 변환을 COO 형식으로 하면 아래와 같음
  ```python
  import numpy as np

  dense = np.array( [[3,0,1], [0, 2, 0]])

  from scipy import sparse

  # 0이 아닌 데이터 추출
  data = np.array([3, 1, 2])

  # 행 위치와 열 위치를 각각 배열로 생성
  row_pos = np.array([0, 0, 1])
  col_pos = np.array([0, 2, 1])

  # sparse 패키지의 coo_matrix를 이용해 COO 형식으로 희소 행렬 생성
  sparse_coo = sparse.coo_matrix((data, (row_pos, col_pos)))
  sparse_coo.toarray()
  ```

### 1.2 CSR 형식 (Compressed Sparse Row)
- COO 형식이 행과 열의 위치를 나타내기 위해서 반복적인 위치 데이터를 사용해야 하는 문제점을 해결한 방식
- COO 변환 형식의 문제점  
  ![image](https://github.com/seungye-kwak/til_log/assets/112370282/ec395032-ed98-46f8-97a6-db7f312b1742)  
  + 행 위치 배열 [0, 0, 1, 1, 1, 1, 1, 2, 2, 3, 4, 4, 5]를 주의깊게 보면 순차적인 같은 값이 반복적으로 나타남. (0이 2번, 1이 5번...)
- 행 위치 배열이 0부터 순차적으로 증가하는 값으로 이뤄졌다는 특성을 고려하면 행 위치 배열의 고유한 값의 시작 위치만 표기하는 방법으로 이러한 반복을 제거할 수 있음 (위치의 위치를 표기하는 것)
- 행 위치 배열의 첫 번째(인덱스 0)는 0, 두 번째(인덱스 1)는 0, 세 번째(인덱스 2)는 1이라면 행 위치 배열의 고유값 시작 위치는 첫 번째와 세 번째이고 인덱스 기준으로 [0, 2] 임
- CSR은 Compressed Sparse Row의 약자이며, 이처럼 행 ㅇ위치 배열 내에 있는 고유한 값의 시작 위치만 다시 별도의 위치 배열로 가지는 변환 방식을 의미함
- 다음 그림은 위 그림의 행 위치 배열을 CSR로 변환하는 방식을 나타냄. 행 위치 배열 [0, 0, 1, 1, 1, 1, 1, 2, 2, 3, 4, 4, 5]을 CSR 로 변환하면 [0, 2, 7, 9, 10, 12]가 됨 (고유값의 수와 같음)  
  ![image](https://github.com/seungye-kwak/til_log/assets/112370282/4dd698c7-6553-4af0-ba53-86cb62cdb720)
  + 이렇게 고유 값의 시작 위치만 알고 있으면 얼마든지 행 위치 배열을 다시 만들 수 있기 때문에 COO 방식보다 메모리가 적게 들고 빠른 연산이 가능함
```python
from scipy import sparse

dense2 = np.array([[0, 0, 1, 0, 0, 5], 
                   [1, 4, 0, 3, 2, 5], 
                   [0, 6, 0, 3, 0, 0], 
                   [2, 0, 0, 0, 0, 0], 
                   [0, 0, 0, 7, 0, 8],
                   [1, 0, 0, 0, 0, 0]])

# 0 0| 아닌 데이터 추출
data2 = np.array([1, 5, 1, 4, 3, 2, 5, 6, 3, 2, 7, 8, 1])

# 행 위치와 열 위치를 각각 array로 생성
row_pos = np.array([0, 0, 1, 1, 1, 1, 1, 2, 2, 3, 4, 4, 5]) 
col_pos = np.array([2, 5, 0, 1, 3, 4, 5, 1, 3, 0, 3, 5, 0])

# COO 형식으로 변환 (행 위치 배열)
sparse_coo = sparse.coo_matrix((data2, (row_pos, col_pos)))

# 행 위치 배열의 고유한 값의 시작 위치 인덱스를 배열로 생성
row_pos_ind = np.array([0, 2, 7, 9, 10, 12, 13])

# CSR 형식으로 변환
sparse_csr = sparse.csr_matrix((data2, col_pos, row_pos_ind))
print('COO 변환된 데이터가 제대로 되었는지 다시 Dense로 출력 확인') 
print(sparse_coo.toarray())
print('CSR 변환된 데이터가 제대로 되었는지 다시 Dense로 출력 확인') 
print(sparse_csr.toarray())
```
- CSR 장단점 정리 (출처 : https://rfriend.tistory.com/551)  
  ![image](https://github.com/seungye-kwak/til_log/assets/112370282/876cbd7b-3b3e-48b8-a444-6cf1df5f21b4)  



